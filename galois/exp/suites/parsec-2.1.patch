diff -Naur parsec-2.1/CMakeLists.txt parsec-2.1.patched/CMakeLists.txt
--- parsec-2.1/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/CMakeLists.txt	2012-05-11 13:25:16.917650758 -0500
@@ -0,0 +1,20 @@
+add_definitions(-DPARSEC_VERSION=2.1)
+add_definitions(-DENABLE_PARSEC_HOOKS)
+# Parsec-specific OpenMP flag is enabled but via GALOIS_CHANGE we don't actually use OpenMP 
+add_definitions(-DENABLE_OPENMP)
+add_definitions(-DGALOIS_CHANGE)
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -funroll-loops -fprefetch-loop-arrays")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3 -funroll-loops -fprefetch-loop-arrays -fpermissive")
+
+include_directories(pkgs/libs/hooks/src/include)
+add_subdirectory(pkgs/libs/hooks)
+
+add_subdirectory(pkgs/apps/blackscholes)
+add_subdirectory(pkgs/apps/bodytrack)
+if(CMAKE_SIZEOF_VOID_P EQUAL 4)
+  add_subdirectory(pkgs/apps/freqmine)
+else()
+  message(STATUS "parsec freqmine benchmark skipped for non 32-bit platforms")
+endif()
+add_subdirectory(inputs)
diff -Naur parsec-2.1/inputs/CMakeLists.txt parsec-2.1.patched/inputs/CMakeLists.txt
--- parsec-2.1/inputs/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/inputs/CMakeLists.txt	2012-05-10 17:50:43.063149826 -0500
@@ -0,0 +1 @@
+add_custom_target(more-suites-inputs-parsec ${CMAKE_CURRENT_SOURCE_DIR}/download_native.sh)
diff -Naur parsec-2.1/inputs/download_native.sh parsec-2.1.patched/inputs/download_native.sh
--- parsec-2.1/inputs/download_native.sh	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/inputs/download_native.sh	2012-05-10 18:42:48.592364332 -0500
@@ -0,0 +1,18 @@
+#!/bin/bash
+
+set -e # stop on first error
+
+if [[ ! -f parsec-2.1-native.tar.gz ]]; then
+  wget http://parsec.cs.princeton.edu/download/2.1/parsec-2.1-native.tar.gz
+fi
+
+if [[ ! -f parsec-2.1/pkgs/apps/freqmine/inputs/input_native.tar ]]; then
+  tar xzvf parsec-2.1-native.tar.gz
+fi
+
+for app in bodytrack freqmine blackscholes; do
+  if [[ ! -d $app ]]; then
+    mkdir $app
+    tar xvf parsec-2.1/pkgs/apps/$app/inputs/input_native.tar -C $app
+  fi
+done
diff -Naur parsec-2.1/pkgs/apps/blackscholes/CMakeLists.txt parsec-2.1.patched/pkgs/apps/blackscholes/CMakeLists.txt
--- parsec-2.1/pkgs/apps/blackscholes/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/pkgs/apps/blackscholes/CMakeLists.txt	2012-05-10 17:12:39.775246508 -0500
@@ -0,0 +1,5 @@
+set_source_files_properties(src/blackscholes.c PROPERTIES LANGUAGE CXX)
+add_executable(parsec-blackscholes src/blackscholes.c)
+target_link_libraries(parsec-blackscholes m)
+target_link_libraries(parsec-blackscholes parsec-hooks)
+addsuite(parsec-blackscholes)
diff -Naur parsec-2.1/pkgs/apps/blackscholes/src/blackscholes.c parsec-2.1.patched/pkgs/apps/blackscholes/src/blackscholes.c
--- parsec-2.1/pkgs/apps/blackscholes/src/blackscholes.c	2009-07-27 18:58:11.000000000 -0500
+++ parsec-2.1.patched/pkgs/apps/blackscholes/src/blackscholes.c	2012-05-10 16:30:52.820388270 -0500
@@ -27,8 +27,12 @@
 
 // Multi-threaded OpenMP header
 #ifdef ENABLE_OPENMP
+#ifdef GALOIS_CHANGE
+#include "Exp/Parallel.h"
+#else
 #include <omp.h>
 #endif
+#endif
 
 // Multi-threaded header for Windows
 #ifdef WIN32
@@ -232,8 +236,12 @@
 
     for (j=0; j<NUM_RUNS; j++) {
 #ifdef ENABLE_OPENMP
+#ifdef GALOIS_CHANGE
+        parallel_doall(int, i, 0, numOptions) {
+#else
 #pragma omp parallel for
         for (i=0; i<numOptions; i++) {
+#endif
 #else  //ENABLE_OPENMP
         for (i=start; i<end; i++) {
 #endif //ENABLE_OPENMP
@@ -254,8 +262,10 @@
             }
 #endif
         }
+#if defined(ENABLE_OPENMP) && defined(GALOIS_CHANGE)
+      parallel_doall_end
+#endif
     }
-
     return 0;
 }
 
@@ -375,9 +385,14 @@
 #else//ENABLE_THREADS
 #ifdef ENABLE_OPENMP
     {
+#ifdef GALOIS_CHANGE
+        int tid=0;
+        bs_thread(&tid);
+#else
         int tid=0;
         omp_set_num_threads(nThreads);
         bs_thread(&tid);
+#endif
     }
 #else //ENABLE_OPENMP
 #ifdef WIN32 
diff -Naur parsec-2.1/pkgs/apps/bodytrack/CMakeLists.txt parsec-2.1.patched/pkgs/apps/bodytrack/CMakeLists.txt
--- parsec-2.1/pkgs/apps/bodytrack/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/pkgs/apps/bodytrack/CMakeLists.txt	2012-05-10 17:31:47.984782121 -0500
@@ -0,0 +1,24 @@
+add_definitions(-DUSE_OPENMP=1)
+include(CheckIncludeFile)
+CHECK_INCLUDE_FILE("stdint.h" HAVE_STDINT_H)
+if(HAVE_STDINT_H)
+  add_definitions(-DHAVE_STDINT_H)
+endif()
+
+include_directories(src/FlexImageLib)
+file(GLOB Lib src/FlexImageLib/*.cpp)
+set(Sources
+  src/TrackingBenchmark/AnnealingFactor.cpp
+  src/TrackingBenchmark/CameraModel.cpp
+  src/TrackingBenchmark/main.cpp
+  src/TrackingBenchmark/CovarianceMatrix.cpp
+  src/TrackingBenchmark/RandomGenerator.cpp
+  src/TrackingBenchmark/BodyGeometry.cpp
+  src/TrackingBenchmark/ImageMeasurements.cpp 
+  src/TrackingBenchmark/TrackingModel.cpp
+  src/TrackingBenchmark/BodyPose.cpp
+  src/TrackingBenchmark/ImageProjection.cpp
+  src/TrackingBenchmark/TrackingModelOMP.cpp)
+add_executable(parsec-bodytrack ${Lib} ${Sources})
+target_link_libraries(parsec-bodytrack parsec-hooks)
+addsuite(parsec-bodytrack)
diff -Naur parsec-2.1/pkgs/apps/bodytrack/src/TrackingBenchmark/main.cpp parsec-2.1.patched/pkgs/apps/bodytrack/src/TrackingBenchmark/main.cpp
--- parsec-2.1/pkgs/apps/bodytrack/src/TrackingBenchmark/main.cpp	2008-11-06 14:01:14.000000000 -0600
+++ parsec-2.1.patched/pkgs/apps/bodytrack/src/TrackingBenchmark/main.cpp	2012-05-11 17:26:34.431964494 -0500
@@ -38,7 +38,9 @@
 //#define USE_TBB
 
 #if defined(USE_OPENMP)
+#ifndef GALOIS_CHANGE
 #include <omp.h>
+#endif
 #include "ParticleFilterOMP.h"
 #include "TrackingModelOMP.h"
 #endif //USE_OPENMP
@@ -163,12 +165,13 @@
 int mainOMP(string path, int cameras, int frames, int particles, int layers, int threads, bool OutputBMP)
 {
 	cout << "Threading with OpenMP" << endl;
+#ifndef GALOIS_CHANGE
 	if(threads < 1)																		//Set number of threads used by OpenMP
 		omp_set_num_threads(omp_get_num_procs());										//use number of processors by default
 	else
 		omp_set_num_threads(threads);
 	cout << "Number of Threads : " << omp_get_max_threads() << endl;
-
+#endif
 	TrackingModelOMP model;
 	if(!model.Initialize(path, cameras, layers))										//Initialize model parameters
 	{	cout << endl << "Error loading initialization data." << endl;
diff -Naur parsec-2.1/pkgs/apps/bodytrack/src/TrackingBenchmark/ParticleFilterOMP.h parsec-2.1.patched/pkgs/apps/bodytrack/src/TrackingBenchmark/ParticleFilterOMP.h
--- parsec-2.1/pkgs/apps/bodytrack/src/TrackingBenchmark/ParticleFilterOMP.h	2008-07-11 14:21:02.000000000 -0500
+++ parsec-2.1.patched/pkgs/apps/bodytrack/src/TrackingBenchmark/ParticleFilterOMP.h	2012-05-11 17:28:23.197060270 -0500
@@ -23,7 +23,11 @@
 # include "config.h"
 #endif
 
+#ifdef GALOIS_CHANGE
+#include "Exp/Parallel.h"
+#else
 #include <omp.h>
+#endif
 #include "ParticleFilter.h"
 
 template<class T> 
@@ -64,13 +68,25 @@
 	mWeights.resize(particles.size());
 
 	int np = (int)particles.size(), j;
+#ifdef GALOIS_CHANGE
+        ParticleFilterOMP<T>* self = this;
+        parallel_doall_1(int, j, 0, np)
+	{	bool vflag;
+                int n = Exp::getTID();
+		self->mWeights[j] = self->mModel->LogLikelihood(particles[j], vflag, n);						//compute log-likelihood weights for each particle
+		valid[j] = vflag ? 1 : 0;
+	}
+        parallel_doall_end
+#else
 	#pragma omp parallel for																//OpenMP parallelized loop to compute log-likelihoods
 	for(j = 0; j < np; j++) 
 	{	bool vflag;
 		int n = omp_get_thread_num();
-		mWeights[j] = mModel->LogLikelihood(particles[j], vflag, n);						//compute log-likelihood weights for each particle
+		XXX mWeights[j] = mModel->LogLikelihood(particles[j], vflag, n);						//compute log-likelihood weights for each particle
 		valid[j] = vflag ? 1 : 0;
 	}
+#endif
+
 	uint i = 0;
 	while(i < particles.size())
 	{	if(!valid[i])																		//if not valid(model prior), remove the particle from the list
@@ -108,11 +124,21 @@
 	for(int i = 0; i < (int)mBins.size(); i++)										
 		for(uint j = 0; j < mBins[i]; j++)													//index particles to be regenerated
 			mIndex[p++] = i;
+
+#ifdef GALOIS_CHANGE
+        ParticleFilterOMP<T>* self = this;
+        parallel_doall(int, i, 0, mNParticles)
+	{	self->mNewParticles[i] = self->mParticles[self->mIndex[i]];											//add new particle for each entry in each bin distributed randomly about duplicated particle
+		self->AddGaussianNoise(self->mNewParticles[i], self->mModel->StdDevs()[k], self->mRnd[i]);
+	}
+        parallel_doall_end
+#else
 	#pragma omp parallel for
 	for(int i = 0; i < mNParticles; i++)													//distribute new particles randomly according to model stdDevs
 	{	mNewParticles[i] = mParticles[mIndex[i]];											//add new particle for each entry in each bin distributed randomly about duplicated particle
 		AddGaussianNoise(mNewParticles[i], mModel->StdDevs()[k], mRnd[i]);
 	}
+#endif
 }
 
 
diff -Naur parsec-2.1/pkgs/apps/bodytrack/src/TrackingBenchmark/TrackingModelOMP.cpp parsec-2.1.patched/pkgs/apps/bodytrack/src/TrackingBenchmark/TrackingModelOMP.cpp
--- parsec-2.1/pkgs/apps/bodytrack/src/TrackingBenchmark/TrackingModelOMP.cpp	2008-07-07 11:42:42.000000000 -0500
+++ parsec-2.1.patched/pkgs/apps/bodytrack/src/TrackingBenchmark/TrackingModelOMP.cpp	2012-05-10 16:44:06.149225595 -0500
@@ -25,6 +25,10 @@
 #include <omp.h>
 #include "system.h"
 
+#ifdef GALOIS_CHANGE
+#include "Exp/Parallel.h"
+#endif
+
 using namespace std;
 
 
@@ -40,8 +44,12 @@
 		dst.Reallocate(src.Size());
 	dst.Set((T)0);
 	int n = kernelSize / 2, h = src.Height();
+#ifdef GALOIS_CHANGE
+        parallel_doall(int, y, 0, h)
+#else
 	#pragma omp parallel for
 	for(int y = 0; y < h; y++)
+#endif
 	{	T *psrc = &src(n, y), *pdst = &dst(n, y);
 		for(int x = n; x < src.Width() - n; x++)
 		{	int k = 0;
@@ -53,6 +61,9 @@
 			psrc++;
 		}
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	return true;
 }
 
@@ -67,8 +78,12 @@
 	dst.Set((T)0);
 	int n = kernelSize / 2;
 	int sb = src.StepBytes(), h = src.Height() - n;
+#ifdef GALOIS_CHANGE
+        parallel_doall(int, y, n, h)
+#else
 	#pragma omp parallel for
 	for(int y = n; y < h; y++)
+#endif
 	{	T *psrc = &src(0, y), *pdst = &dst(0, y);
 		for(int x = 0; x < src.Width(); x++)
 		{	int k = 0;
@@ -80,6 +95,9 @@
 			psrc++;
 		}
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	return true;
 }
 
@@ -100,8 +118,12 @@
 {
 	FlexImage8u r(src.Size());
 	ZeroBorder(r);
+#ifdef GALOIS_CHANGE
+        parallel_doall(int, y, 1, src.Height() - 1)
+#else
 	#pragma omp parallel for
 	for(int y = 1; y < src.Height() - 1; y++)																					//for each pixel
+#endif
 	{	Im8u *p = &src(1,y), *ph = &src(1,y - 1), *pl = &src(1,y + 1), *pr = &r(1,y);
 		for(int x = 1; x < src.Width() - 1; x++)
 		{	float xg = -0.125f * ph[-1] + 0.125f * ph[1] - 0.250f * p[-1] + 0.250f * p[1] - 0.125f * pl[-1] + 0.125f * pl[1];	//calc x and y gradients
@@ -111,6 +133,9 @@
 			p++; ph++; pl++; pr++;
 		}
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	return r;
 }
 
@@ -155,4 +180,4 @@
 		CreateEdgeMap(im, mEdgeMaps[i]);										//Create edge maps
 	}
 	return true;
-}
\ No newline at end of file
+}
diff -Naur parsec-2.1/pkgs/apps/freqmine/CMakeLists.txt parsec-2.1.patched/pkgs/apps/freqmine/CMakeLists.txt
--- parsec-2.1/pkgs/apps/freqmine/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/pkgs/apps/freqmine/CMakeLists.txt	2012-05-11 01:25:04.532810325 -0500
@@ -0,0 +1,5 @@
+file(GLOB Sources src/*.cpp)
+#set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32") 
+add_executable(parsec-freqmine ${Sources})
+target_link_libraries(parsec-freqmine parsec-hooks)
+addsuite(parsec-freqmine)
diff -Naur parsec-2.1/pkgs/apps/freqmine/src/fp_tree.cpp parsec-2.1.patched/pkgs/apps/freqmine/src/fp_tree.cpp
--- parsec-2.1/pkgs/apps/freqmine/src/fp_tree.cpp	2009-01-21 10:09:15.000000000 -0600
+++ parsec-2.1.patched/pkgs/apps/freqmine/src/fp_tree.cpp	2012-05-11 13:20:20.614666816 -0500
@@ -42,12 +42,19 @@
 #include "common.h"
 #include "wtime.h"
 
+#ifdef GALOIS_CHANGE
+#include "Exp/Parallel.h"
+#include <pthread.h>
+static int omp_get_max_threads() { return Exp::getNumThreads(); }
+static int omp_get_thread_num() { return Exp::getTID(); }
+#else
 #ifdef _OPENMP
 #include <omp.h>
 #else
 static int omp_get_max_threads() {return 1;}
 static int omp_get_thread_num() {return 0;}
 #endif //_OPENMP
+#endif
 
 #define fast_rightsib_table_size 16
 int ***currentnodeiter;
@@ -207,8 +214,12 @@
 	}
 	new_data_num[0][0] = sum_new_data_num;
 	T *ItemArray = (T *)local_buf->newbuf(1, new_data_num[0][0] * sizeof(T));
+#ifdef GALOIS_CHANGE
+        parallel_doall_1(int, j, 0, workingthread) {
+#else
 #pragma omp parallel for
 	for (j = 0; j < workingthread; j ++) {
+#endif
 		int kept_itemiter;
 		int itemiter = content_offset_array[j] - 1;
 		int stacktop;
@@ -282,6 +293,9 @@
 			}
 		}
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	fptree->ItemArray = (int *) ItemArray;
 }
 
@@ -529,8 +543,12 @@
 		for (j = local_num_hot_item; j < local_itemno; j ++)
 			origin[i][j] = 1;
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_1(int, i, 0, mapfile->tablesize) {
+#else
 #pragma omp parallel for schedule(dynamic,1)
 	for (i = 0; i < mapfile->tablesize; i ++) {
+#endif
 		int k, l;
 		int *content;
 		MapFileNode *currentnode;
@@ -623,6 +641,9 @@
 			currentnode->finalize();
 			thread_pos[thread] = currentpos;
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	
 	for (i = 0; i < workingthread; i ++) {
 		thread_pos[i] = 0;
@@ -713,8 +734,12 @@
 			}
 		}
 
+#ifdef GALOIS_CHANGE
+        parallel_doall_1(int, i, 0, workingthread) {
+#else
 #pragma omp parallel for
 	for (i = 0; i < workingthread; i ++) {
+#endif
 		MapFileNode *current_mapfilenode;
 		unsigned short * content;
 		int k, size, current_pos, ntype, has;
@@ -738,6 +763,9 @@
 			current_mapfilenode = current_mapfilenode->next;
 		}
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	delete [] tempntypeoffsetbase;
 	delete [] thread_pos;
 }
@@ -865,9 +893,15 @@
 			hot_node_index[i] = j;
 	}
 	hot_node_depth[0] = 0;
+
+#ifdef GALOIS_CHANGE
+        parallel_doall_1(int, k, 0, workingthread) {
+#else
 	#pragma omp parallel for
 	for (int k = 0; k < workingthread; k ++) {
+#endif
 		int i;
+#ifndef GALOIS_CHANGE
 #ifdef __linux__
 #ifdef CPU_SETSIZE
 		cpu_set_t cpu_mask; 
@@ -880,6 +914,7 @@
 		sched_setaffinity(k, sizeof(unsigned long), &cpu_mask);
 #endif
 #endif
+#endif
 		currentnodeiter[k] = (int**)fp_buf[k]->newbuf(1, itemno * (14 + fast_rightsib_table_size) * sizeof(int *) + num_hot_node * 2 * sizeof(int *)  + (fast_rightsib_table_size * itemno) * sizeof(int *) + fast_rightsib_table_size + 3 * sizeof(int*));
 		nodestack[k] = (Fnode**)(currentnodeiter[k] + itemno);
 		itemstack[k] = (int*)(nodestack[k] + itemno);
@@ -922,6 +957,9 @@
 			bran[k][i] = 0;
 		}
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	mapfile->transform_list_table();
 	for (i = 0; i < hot_node_num; i ++)
 		ntypeidarray[i] = i;
@@ -1049,8 +1087,12 @@
 	wtime(&tstart);
 	database_tiling(workingthread);
 	Fnode **local_hashtable = hashtable[0];
+#ifdef GALOIS_CHANGE
+        parallel_doall_1(int, j, 0, mergedworknum) {
+#else
 #pragma omp parallel for schedule(dynamic,1)
 	for (j = 0; j < mergedworknum; j ++) {
+#endif
 		int thread = omp_get_thread_num();
 		int localthreadworkloadnum = threadworkloadnum[thread];
 		int *localthreadworkload = threadworkload[thread];
@@ -1154,6 +1196,9 @@
 		rightsib_backpatch_count[thread][0] = local_rightsib_backpatch_count;
 		threadworkloadnum[thread] = localthreadworkloadnum;
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	delete database_buf;
 	
 	for (int i = 0; i < workingthread; i ++) {
@@ -1163,13 +1208,20 @@
 	}
 	int totalnodes = cal_level_25(0);
 	
+#ifdef GALOIS_CHANGE
+        parallel_doall_1(int, j, 0, workingthread) {
+#else
 #pragma omp parallel for
 	for (j = 0; j < workingthread; j ++) {
+#endif
 		int local_rightsib_backpatch_count = rightsib_backpatch_count[j][0];
 		Fnode ***local_rightsib_backpatch_stack = rightsib_backpatch_stack[j];
 		for (int i = 0; i < local_rightsib_backpatch_count; i ++)
 			*local_rightsib_backpatch_stack[i] = NULL;
 	}
+#ifdef GALOIS_CHANGE
+        parallel_doall_end
+#endif
 	wtime(&tend);
 //	printf("Creating the first tree from source file cost %f seconds\n", tend - tstart);
 //       printf("we have %d nodes in the initial FP tree\n", totalnodes);
@@ -1244,6 +1296,10 @@
 	return true;
 }
 
+#ifdef GALOIS_CHANGE
+pthread_mutex_t release_node_array_after_mining_lock = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
 void FP_tree::release_node_array_after_mining(int sequence, int thread, int workingthread)
 {
 	int current, i;
@@ -1254,17 +1310,28 @@
 			current = thread_finish_status[i];
 	}
 {
+#ifdef GALOIS_CHANGE
+        pthread_mutex_lock(&release_node_array_after_mining_lock);
+#else
 #pragma omp critical
+#endif
 	{
 		if (current < released_pos) {
 			released_pos = current;
 			fp_node_sub_buf->freebuf(MR_nodes[current], MC_nodes[current], MB_nodes[current]);
 		}
 	}
+#ifdef GALOIS_CHANGE
+        pthread_mutex_unlock(&release_node_array_after_mining_lock);
+#endif
 }
 
 }
 
+#ifdef GALOIS_CHANGE
+pthread_mutex_t release_node_array_before_mining_lock = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
 void FP_tree::release_node_array_before_mining(int sequence, int thread, int workingthread)
 {
 	int current, i;
@@ -1276,13 +1343,20 @@
 	}
 	current ++;
 {
+#ifdef GALOIS_CHANGE
+        pthread_mutex_lock(&release_node_array_before_mining_lock);
+#else
 #pragma omp critical
+#endif
 	{
 		if (current < released_pos) {
 			released_pos = current;
 			fp_node_sub_buf->freebuf(MR_nodes[current], MC_nodes[current], MB_nodes[current]);
 		}
 	}
+#ifdef GALOIS_CHANGE
+        pthread_mutex_unlock(&release_node_array_before_mining_lock);
+#endif
 }
 
 }
@@ -1340,9 +1414,15 @@
 			}
 		}
 
+#ifdef GALOIS_CHANGE
+                parallel_doall_1(int, sequenceprime, 0, upperbound-lowerbound + 1) {
+                        int sequence = upperbound - 1 - sequenceprime;
+#else
 		#pragma omp parallel for schedule(dynamic,1)
 		for(sequence=upperbound - 1; sequence>=lowerbound; sequence--)
-		{	int current, new_item_no, listlen;
+		{	
+#endif
+                  	int current, new_item_no, listlen;
 			int MC2=0;			
 			unsigned int MR2=0;	
 			char* MB2;		
@@ -1381,7 +1461,11 @@
 				}
 				local_list->top=listlen-1;
 				release_node_array_after_mining(sequence, thread, workingthread);
+#ifdef GALOIS_CHANGE
+                                goto loop_end;
+#else
 				continue;
+#endif
 			}
 
 			FP_tree *fptree;
@@ -1421,7 +1505,13 @@
 				local_list->top = listlen-1;
 			}
 			release_node_array_after_mining(sequence, thread, workingthread);
+#ifdef GALOIS_CHANGE
+loop_end:               ;
+#endif
 		}
+#ifdef GALOIS_CHANGE
+                parallel_doall_end
+#endif
 	}
 	 wtime(&tend);
 //	 printf("the major FP_growth cost %f vs %f seconds\n", tend - tstart, temp_time - tstart);
diff -Naur parsec-2.1/pkgs/libs/hooks/CMakeLists.txt parsec-2.1.patched/pkgs/libs/hooks/CMakeLists.txt
--- parsec-2.1/pkgs/libs/hooks/CMakeLists.txt	1969-12-31 18:00:00.000000000 -0600
+++ parsec-2.1.patched/pkgs/libs/hooks/CMakeLists.txt	2012-05-10 12:34:42.760712464 -0500
@@ -0,0 +1,2 @@
+add_definitions(-D_GNU_SOURCE)
+add_library(parsec-hooks src/hooks.c)
